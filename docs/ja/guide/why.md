---
title: Why Vitest | Guide
---

# Vitest を選ぶ理由 {#why-vitest}

:::tip NOTE
このガイドは、Vite に精通していることを前提としています。詳細を学ぶには、[Why Vite Guide](https://ja.vitejs.dev/guide/why.html) と、[Evan You](https://twitter.com/youyuxi) が主な概念を説明するデモを行ったストリームである [ViteJS を使用した次世代フロントエンドツール](https://www.youtube.com/watch?v=UJypSr8IhKY) を読むことをお勧めします。
:::

## Vite ネイティブ テスト ランナーの必要性 {#the-need-for-a-vite-native-test-runner}

一般的な Web パターン、glob インポートや SSR プリミティブなどの機能に対する Vite のすぐに使えるサポート、およびその多くのプラグインと統合は、活気のあるエコシステムを育んでいます。その開発と構築のストーリーが成功の鍵です。ドキュメントについては、Vite を利用した SSG ベースの代替手段がいくつかあります。ただし、Vite の単体テストのストーリーは明確ではありません。[Jest](https://jestjs.io/) などの既存のオプションは、別のコンテキストで作成されました。Jest と Vite の間には多くの重複があり、ユーザーは 2 つの異なるパイプラインを構成する必要があります。

Vite dev server を使ってテスト中にファイルを変換することで、複雑なソースファイルの変換に対応する必要がなく、テスト中に最高の DX を提供することだけに集中できるシンプルなランナーを作成することができます。アプリの同じ構成を (`vite.config.js` を介して) 使用し、開発、ビルド、およびテスト時に共通の変換パイプラインを共有するテストランナーです。それは、あなたやあなたのツールのメンテナがViteとファーストクラスの統合を提供できるように、同じプラグイン API で拡張可能です。Vite のインスタントHMR（Hot Module Reload）など、DX の改良点を生かし、最初から Vite を意識して作られたツールです。Vitest は、Vite を利用した高速なユニットテストフレームワークです。

Jest の大規模な採用を考慮し、Vitest は互換性のある API を提供しているため、ほとんどのプロジェクトで Jest をドロップインで使用することができます。また、ユニットテストをセットアップする際に必要となる最も一般的な機能（モッキング、スナップショット、カバレッジ）も含まれています。Vitest はパフォーマンスを重視しており、Worker スレッドを用いて可能な限り並列に動作させています。一部のポートでは、テストの実行が桁違いに高速であることが確認されています。ウォッチモードがデフォルトで有効になっており、Vite が推し進めるデベロッパーのファーストエクスペリエンスに合致しています。このように DX が進化しても、Vitest は依存関係を慎重に選択する（あるいは必要な部分を直接インライン化する）ことで軽量性を保っています。

**Vitest は、Vite プロジェクトのためのテストランナーとして、また Vite を使用しないプロジェクトのための確かな代替手段として位置づけられることを目指しています。**

続きは [Getting Started Guide](./index) で

## Vitest は X とどう違うのか？ {#how-is-vitest-different-from-x}

Vitest と他の類似ツールとの違いについては、[Comparisons](./comparisons) セクションで詳しく説明されています。
